       DEF  AEQ,MAKETX,PRINTL
       REF  VMBW,VMBR

TRUE   DATA >0001
FALSE  DATA >0000
WORKSP BSS  >20
STACK  BSS  >100

* Assert Words Are Equal
* ----------------------
* Return true if contents of R2 and R3
* are equal. Displays their contents if
* not equal.
* R0: Address of test name
* R1: Length of test name
* R2: Expected value
* R3: Actual value
* R4-> 1 = true, 0 = false
AEQ    DATA WORKSP,AEQP
AEQMES TEXT 'Expected '
AEQM1  BSS  >4
       TEXT ' but actual '
AEQM2  BSS  >4
       TEXT '.'
AEQME  EVEN
AEQP   LI   R12,STACK
* Copy Parameters
       BL   @COPYP
* Output Test Name
       BL   @OTN
       C    R2,R3
       JEQ  AEQS
* Report failure
       BL   @RF
       DATA AEQM1,AEQM2
       DATA AEQMES,AEQME-AEQMES
       RTWP
* Report success
AEQS   BL   @RS
       RTWP
AEQNOT
       RTWP

*Copy Parameters to Registers
COPYP  MOV  *R13+,R0
       MOV  *R13+,R1
       MOV  *R13+,R2
       MOV  *R13+,R3
       AI   R13,-8
       RT

*Output Test Name
* R0: Address of test name
* R1: length of test name
OTN    MOV  R11,*R12+
*Print to screen
       BL   @PTNS
*Print to output file
*      BL   @PTNOF
       DECT R12
       MOV  *R12,R11
       RT

*Print Test Name to Screen
PTNST  TEXT 'Running test:'
PTNST2 EVEN
PTNS   MOV  R11,*R12+
       MOV  R0,*R12+
       MOV  R1,*R12+
       LI   R0,PTNST
       LI   R1,PTNST2-PTNST
       BL   @SCRLP
       DECT R12
       MOV  *R12,R1
       DECT R12
       MOV  *R12,R0
       BL   @SCRLP
       DECT R12
       MOV  *R12,R11
       RT

*Report Success
RST    TEXT 'Success.'
RST2   EVEN
RS     MOV  R11,*R12+
       MOV  R0,*R12+
       MOV  R1,*R12+
       LI   R0,RST
       LI   R1,RST2-RST
       BL   @SCRLP
       MOV  @TRUE,@8(R13)
       DECT R12
       MOV  *R12,R1
       DECT R12
       MOV  *R12,R0
       DECT R12
       MOV  *R12,R11
       RT

*Report Failure
* R2: Expected Value
* R3: Actual Value
* Memory Addresses after BL command
* +02: Dest address of expected text
* +04: Dest address of actual text
* +06: Address of failure message
* +08: length of failure message
RF     MOV  R10,*R12+
       MOV  R0,*R12+
       MOV  R1,*R12+

       MOV  R11,R10
* Convert values to Hexadecimal Text.
       MOV  R2,R0
       MOV  *R10+,R1
       BL   @MAKEHX
       MOV  R3,R0
       MOV  *R10+,R1
       BL   @MAKEHX
* Display message
       MOV  *R10+,R0
       MOV  *R10+,R1
       BL   @SCRLP
       MOV  @FALSE,@8(R13)
       MOV  R10,R11

       DECT R12
       MOV  *R12,R1
       DECT R12
       MOV  *R12,R0
       DECT R12
       MOV  *R12,R10
       RT

*Make Hexadecimal Text
* R0: Word to convert.
* R1: Address output text (4 bytes)
MAKETX DATA WORKSP,MAKEP
MAKEP  LI   R12,STACK
       MOV  @2(R13),R1
       MOV  @0(R13),R0
       BL   @MAKEHX
       RTWP
MAKEHX MOV  R11,*R12+
       MOV  R2,*R12+
       MOVB R0,R2
       BL   @MAKEP1
       SLA  R0,8
       MOVB R0,R2
       BL   @MAKEP1
* return
       DECT R12
       MOV  *R12,R2
       DECT R12
       MOV  *R12,R11
       RT

MAKEP1 MOV  R11,*R12+
       MOV  R4,*R12+
*High Byte
       MOVB R2,R4
       SRL  R4,4
       BL   @CONVB
       MOVB R4,*R1
       INC  R1
*Low Byte
       MOVB R2,R4
       SLA  R4,4
       SRL  R4,4
       BL   @CONVB
       MOVB R4,*R1
       INC  R1
*Return
       DECT R12
       MOV  *R12,R4
       DECT R12
       MOV  *R12,R11
       RT
*Convert Byte to ASCII code
CONVB  CI   R4,>0A00
       JH   CNVB2
       AI   R4,>3000
       RT
CNVB2  AI   R4,>3700
       RT

*Scroll screen upward and place text at
*the bottom of the screen. Can be
*multiple lines.
*R0: Address of text.
*R1: Length of text.
PRINTL DATA WORKSP,PRINTP
LINLNG DATA 32
SCRN   BSS  >300
CLRTXT TEXT '                                '
PRINTP LI   R12,STACK
       MOV  @0(R13),R0
       MOV  @2(R13),R1
       BL   @SCRLP
       RTWP
SCRLP  MOV  R11,*R12+
       MOV  R8,*R12+
       MOV  R9,*R12+
       MOV  R2,*R12+
       MOV  R3,*R12+

       MOV  R0,R8
       MOV  R1,R9
*Find ceiling of text length / 32.
       CLR  R0
       MOV  R9,R1
       DIV  @LINLNG,R0
       MOV  R1,R1
       JEQ  SCROLL
       INC  R0
*R0 contains number of lines to print.
*If R0 = 0, then return to caller.
SCROLL MOV  R0,R0
       JNE  SCROL1
       B    @SCRLRT
*Scroll text by number of lines in R0.
SCROL1 SLA  R0,5
       LI   R1,SCRN
       LI   R2,>300
       S    R0,R2
       BLWP @VMBR
       CLR  R0
       BLWP @VMBW
*Clear the last line of text.
       MOV  R2,R3
       LI   R0,>2E0
       LI   R1,CLRTXT
       LI   R2,>20
       BLWP @VMBW
*Write new text.
*R3 contains length of text scrolled up.
*   Identical to text start position.
       MOV  R3,R0
       MOV  R8,R1
       MOV  R9,R2
       BLWP @VMBW
* return
SCRLRT DECT R12
       MOV  *R12,R3
       DECT R12
       MOV  *R12,R2
       DECT R12
       MOV  *R12,R9
       DECT R12
       MOV  *R12,R8
       DECT R12
       MOV  *R12,R11
       RT
       END
